# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    memo.txt                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: jeguerin <marvin@42.fr>                    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/01/19 14:53:16 by jeguerin          #+#    #+#              #
#    Updated: 2024/01/24 18:20:29 by jeguerin         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

Explication fonction :

void	my_mlx_pixel_put(t_game *game, int x, int y, int color)
{
	char	*pix_add;

	pix_add = game->image_add + (y * game->size_line + x *
		(game->bits_per_pixel / 8));
	*(unsigned int*)pix_add = color;
}

1. void my_mlx_pixel_put(t_data *data, int x, int y, int color):
C'est la signature de la fonction. Elle prend en argument un pointeur
vers une structure t_data (nommée data), les coordonnées x et y du pixel
à dessiner, et la couleur du pixel color.

2. char *dst;:
Déclare un pointeur de type char appelé dst.
Ce pointeur sera utilisé pour stocker l'adresse mémoire à
laquelle le pixel sera écrit.

3. Calcul de l'adresse mémoire :
dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
- data->addr: C'est l'adresse de départ de l'image, obtenue lors de
l'initialisation de l'image avec mlx_new_image.
- y * data->line_length: Cette partie détermine l'offset vertical en
fonction de la ligne actuelle y et de la longueur de ligne line_length.
Cela permet de se déplacer d'une ligne à une autre.
- x * (data->bits_per_pixel / 8): Cette partie détermine l'offset horizontal
en fonction de la colonne actuelle x et du nombre d'octets par pixel
(bits_per_pixel / 8). Cela permet de se déplacer horizontalement.
En combinant ces trois parties, on obtient l'add. mémoire du pixel dans l'image.

L'offset est simplement un décalage ou un déplacement par rapport à un point
de référence. Dans le contexte de la manipulation d'images en informatique,
l'offset est généralement utilisé pour calculer la position d'un élément
(comme un pixel) par rapport au début d'une ligne ou d'une colonne.


Comprendre resolution ecran :
Par convention, on considère que le coin supérieur gauche de l'écran
est l'origine (x = 0, y = 0).
Prenons une résolution d'écran courante, par exemple 1920x1080.
Dans ce cas, cela signifie qu'il y a 1080 lignes de pixels sur l'écran et
que chaque ligne a 1920 pixels. L'axe y est utilisé pour représenter le numéro
de la ligne, tandis que l'axe x est utilisé pour représenter le numéro
de la colonne.

Par exemple, disons que nous voulons dessiner une ligne avec les points
suivants : P1(0, 100) et P2(1920, 100).

Detail du calcul :
- Trouver l'adresse du premier byte du pixel

Pour cet exemple, supposons que nous voulons obtenir le pixel aux
coordonnées (5, 10). Ce que nous voulons, c'est le 5e pixel de la 10e ligne.
Les dimensions de la fenêtre/image sont de 600x300.

Pour commencer, trouvons la ligne correcte. L'appel précédent à
mlx_get_data_addr nous a fourni la valeur line_len, qui est essentiellement
la quantité d'octets prise par une ligne de notre image. Elle équivaut à
image_width * (bpp / 8).

Dans notre cas, un int fait quatre octets, donc c'est 600 * 4 = 2400.

Par conséquent, on peut dire que la première ligne commence à l'indice 0,
la deuxième à l'indice 2400, la troisième à l'indice 4800, et ainsi de suite.

Ainsi, nous pouvons trouver l'indice correct de la ligne en faisant 2400 * 10.

Pour trouver la colonne correcte, nous devrons nous déplacer dans la ligne par
le nombre donné de pixels. Dans notre cas, nous voulons déplacer 5 pixels
"vers la droite". Pour ce faire, nous devons multiplier 5 par le nombre
d'octets qu'un pixel prend réellement (ici 4). Ainsi, nous ferons 5 * 4 = 20.

Si nous résumons, nous pouvons trouver l'indice correct avec le calcul suivant :
index = 2400 * 10 + 5 * 4.


int	render(t_game *game)
{
	display_background(game, WHITE);
	game->shape_height = 50;
	game->shape_width = 50;
	game->x_rect = 100;
	game->y_rect = 100;
	display_rect(game);
	game->shape_height = 50;
	game->shape_width = 50;
	game->x_rect = 200;
	game->y_rect = 200;
	display_rect(game);
	return (0);
}

LES EVENEMENTS :
la fonction mlx_loop, qui lance essentiellement une boucle infinie pour nous,
mais à l'intérieur de cette boucle, des choses se produisent. Et par des choses,
j'entends essentiellement des événements.
Cliquer n'importe où dans la fenêtre avec la souris est un événement.
Appuyer sur une touche en est un autre. Les événements sont essentiellement
tout ce que l'utilisateur peut faire pour interagir avec le programme.

Pour rendre le programme interactif, les événements sont indispensables.
Avant que la fonction mlx_loop ne soit appelée, la minilibx nous permet
d'enregistrer des événements qui peuvent être déclenchés après le démarrage
de la boucle. La minilibx appelle ces fonctions des hooks.

Registering events :
=> Is done using the mlx_hook functions.
=> Events are related to a particular window.

Lorsque vous appelez mlx_loop, votre programme entre dans cette boucle
d'événements et reste bloqué là, réagissant aux événements jusqu'à ce que la
fenêtre soit fermée. Cela permet à votre programme de répondre de manière
interactive aux actions de l'utilisateur.

Afin de pouvoir enregistrer des événements, la minilibx nous fournit un
ensemble de fonctions appelées hooks que nous pourrons utiliser pour
enregistrer des événements avant d'appeler mlx_loop.

Il existe cinq fonctions de hook différentes que nous pouvons utiliser :

- int mlx_mouse_hook(void *win_ptr, int (*funct_ptr)(), void *param);
- int mlx_key_hook(void *win_ptr, int (*funct_ptr)(), void *param);
- int mlx_expose_hook(void *win_ptr, int (*funct_ptr)(), void *param);
- int mlx_loop_hook(void *mlx_ptr, int (*funct_ptr)(), void *param);
- int mlx_hook(void *win_ptr, int x_event, int x_mask, int (*funct)(), void *param);

Discutons rapidement de ce que sont ces paramètres :

- win_ptr est le pointeur vers une fenêtre. Cette fenêtre s'inscrira pour
l'événement donné.
- func_ptr est un pointeur vers une fonction qui renvoie un int et qui prend
des paramètres indéfinis. Attention, (*func_ptr)() n'est pas la même chose
que (*func_ptr)(void) : le dernier signifie AUCUN argument tandis que le
premier signifie "n'importe quel ensemble d'arguments".
- param est l'adresse d'un élément que tu voudrais accéder dans ton func_ptr
lorsque tu géreras les événements. La minilibx n'utilise pas param du tout,
c'est juste un moyen de t'aider à passer des arguments.
- Les hooks mlx_mouse, mlx_key, et mlx_expose

=> Ces hooks sont explicites. Tu peux enregistrer des événements liés au
clavier et à la souris, ainsi que des événements d'exposition.
Les événements d'exposition sont déclenchés lorsque le contenu d'une fenêtre
est perdu (par exemple, lorsque la fenêtre de la minilibx est partiellement ou
entièrement recouverte par une autre) et doit être redessiné.

MLX_HOOK :
La fonction mlx_hook prend cinq arguments. Nous avons déjà expliqué ce que
sont win_ptr, func_ptr et param, mais il y a deux nouveaux paramètres :

- x_event est un entier correspondant au nom de l'événement X.
Tu peux trouver tous les noms d'événements dans l'en-tête X11/X.h.

- x_mask est un masque de bits correspondant à l'événement X.
Il est utilisé par la minilibx pour filtrer les événements reçus par la fenêtre.
La liste de tous les masques disponibles est également définie dans X11/X.h.
